from pyfirmata2 import Arduino, util  # Arduino() opens the Firmata serial link; util has Iterator
from serial.tools import list_ports    # Used to discover available serial (COM) ports
import time                            # Sleep/timestamps
import math                            # Misc math helpers (kept for completeness)
import threading                       # For a tiny, thread-safe "last value" latch
from typing import Callable, Optional  # Type hints only
import pyfirmata2
import keyboard


# Auto-detect the Arduino port - - stop using you dumbass
PORT = pyfirmata2.Arduino.AUTODETECT


board = pyfirmata2.Arduino(PORT)
board.samplingOn()  # Start reporting values



def parse_pin_string(pin_str):
    """
    Parses a pin string and returns a formatted string with pin type, pin number, and mode.
    Supports both 3-part ("a0i", "d9o") and 4-part ("a10i", "d12u") formats.
    
    pin_str: str
        A string representing the pin in the format of either "a0i" or "d12u".
    
    Returns:
        A formatted string: "{pin_type}:{pin_number}:{mode}"
    """
    
    pin_type = pin_str[0]  # 'a' or 'd' - Analog or Digital
    mode = pin_str[-1]     # 'i', 'o', or 'u' - Mode: input, output, or pull-up
    
    # Check if the pin string has 3 characters (e.g., "a0i") or 4 characters (e.g., "d12u")
    if len(pin_str) == 3:
        pin_number = int(pin_str[1])  # Single-digit pin number (0-9)
    elif len(pin_str) == 4:
        pin_number = int(pin_str[1:3])  # Multi-digit pin number (10-99)
    else:
        raise ValueError("Invalid pin string format")
    
    return f"{pin_type}:{pin_number}:{mode}"


def pin_callback(pin_str, board): #This function sets up the pin, the callback, and the latest value store.
    """
    Creates a callback for any pin from a short string like 'a0i' or 'd6u'.
    Returns a getter function for the latest value.
    """
    pin_name = parse_pin_string(pin_str) #the pin name after making it readable by the function made above

    latest_value = None  #will store the most recent reading from this pin.
    lock = threading.Lock() #ensures thread safety, because callbacks run in a separate thread.

    def callback(value): #This function is automatically called by pyFirmata2 whenever the pin updates.
        nonlocal latest_value #lets the nested function modify the latest_value variable.
        with lock: #ensures no two threads try to read/write latest_value at the same time.
            latest_value = value

    def getpin(): #The getter function!   Returns the latest value stored in latest_value.your main program can call it at any time.
        with lock: 
            return latest_value

    pin = board.get_pin(pin_name) #Setting up the pin! gets the pin object from pyFirmata2.
    pin.register_callback(callback)  #tells pyFirmata2 to run your callback function whenever a new reading arrives.
    pin.enable_reporting() #tells the Arduino to start sending values for this pin automatically.

    return getpin



#pins:
a36i = pin_callback("a36i", board)   #better getter
#d9o = board.get_pin('d:9:o') # for the play_tone func  ---   play_tone(speaker_pin, 130.8, 0.3)








 
# T - resolution
# StartVdiff - when the V1
# FinalVdiff - when the v2 and the T
# NormalVdiff - the normal V without magnet
def VperSplusSOUND (T, StartVdiff, FinalVdiff ,NormalV):
    print ("start")
    time.sleep(2)
    V1 = 0
    Timespent = 0.0
    d = 0.0
    V1 = a36i()
    if V1 is None:
        print ("cant get input")
        while V1 is None:
            time.sleep(0.1)
            V1 = a36i()
            print("loop0", a36i())
    while (NormalV - StartVdiff) <= V1 <= (NormalV + StartVdiff): #the V is in the right place, start the M
        time.sleep(T)
        V1 = a36i()
        print("loop1", a36i())
    #V1 is in the starting Va
    V1copy = V1
    while ((NormalV - FinalVdiff) <= V1copy <= (NormalV + FinalVdiff)):
        time.sleep(T)
        Timespent = Timespent + T
        V1copy = a36i()
        print("loop2" , a36i())
            
    #final value
    V2 = a36i()
    if V1 is not None:
        d = abs(V1 - V2)
    if d != 0.0 and Timespent !=0.0:
        print(d, Timespent, (d / Timespent))

        return(d / Timespent)
    else:
        oot = (NormalV - FinalVdiff)/T
        print("nah its 3")
        return(3)
    




while True:
    if keyboard.is_pressed('c'):
        print("starting!")
        time.sleep(1)
        read_a0 = a36i()
        print("the normal is: ", read_a0)

        
        print ("calibrate start d -- ")
        time.sleep(1)
        print ("press c when ready!")
        keyboard.wait('c')
        
        if read_a0 is not None:
            calb_start = read_a0 - a36i()
            print("the readincccg for start is:", a36i())
            print("the start diff is: ", calb_start, )
        else:
            print ("read_a0 is not not None")
            calb_start = 0
        

        print(" ")
        print ("calibrate end d -- ")
        time.sleep(1)
        print ("press c when ready!")
        keyboard.wait('c')
        read_a02 = read_a0
        print(a36i())
        if read_a02 is not None:
            calb_end = read_a02 - a36i()
            print("the reading for end is:", a36i())
            print("the start is: ", calb_end)
        else:
            print ("read_a0 is not not None")
            calb_end = 0


        print(" ")
        print(" ")
        if read_a0 is not None and read_a02 is not None:
            print("press c to start it")
            keyboard.wait('c')
            s = VperSplusSOUND(0.005, calb_start, calb_end, read_a0)




    if keyboard.is_pressed('n'):
        time.sleep(1)
        read_a0 = a36i()
        print(read_a0)

        s = VperSplusSOUND(0.01, 0.007, 0.0254, read_a0)
    # T - resolution
    # StartVdiff - when the V1 
    # FinalVdiff - when the v2 and the T
    # NormalVdiff - the normal V without magnet
    # 2.5v is 0.5   --  1v is 0.2
    #min- 0.4489     start- 0.472    normal - 0.479
    #min- 0.4536
    #normal - 0.4878
#